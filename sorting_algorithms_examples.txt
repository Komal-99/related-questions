Quick Sort
33 55 22 4 28 10 24 56 98 77
33 55 22 4 28 10 24 56 77 98

Insertion Sort
- faster for small arrays (<20) than quick sort
33 55 22 4 28 10 24 56 98 77
(2 swaps later) 22 33 55 4 28 10 24 56 98 77
(3 swaps later) 4 22 33 55 28 10 24 56 98 77

Heap Sort
Build heap O(n log n) if using sift-up and O(n) if using sift-down.
Delete max N times: O (n log n) 
To grasp the intuition behind this difference in complexity, note that the number of swaps that may occur during any one siftUp call increases with the depth of the node on which the call is made. The crux is that there are many (exponentially many) more "deep" nodes than there are "shallow" nodes in a heap, so that siftUp may have its full logarithmic running-time on the approximately linear number of calls made on the nodes at or near the "bottom" of the heap. On the other hand, the number of swaps that may occur during any one siftDown call decreases as the depth of the node on which the call is made increases. Thus, when the siftDown heapify begins and is calling siftDown on the bottom and most numerous node-layers, each sifting call will incur, at most, a number of swaps equal to the "height" (from the bottom of the heap) of the node on which the sifting call is made. In other words, about half the calls to siftDown will have at most only one swap, then about a quarter of the calls will have at most two swaps, etc.
https://en.wikipedia.org/wiki/Heapsort

Merge sort:
- divide array into two halves. call mergesort on each half. return if N=1. merge two halves.
33 55 22 4 28 10 24 56 98 77
33 55 22 4 28
33 55
33
55 
merge [33 55]
22 [4 28]
22
4
28
merge [4 28]
merge [4 22 28]
merge [2 33 28 33 55]. left half done. do same for right half. merge.
T(N) = 2T(N/2) + N (merge step)